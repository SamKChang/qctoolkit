// C routine to write CUBE file

#include<Python.h>
#include <numpy/arrayobject.h>

/////////////////////////////////////////
// main function for writing CUBE file //
/////////////////////////////////////////
// or what ever computation need to be done
// only minor changes should be necessary
// to interface other type of calculation
void writecube_c(char *file_name, 
                 double *grid, 
                 double *structure, 
                 double *data,
                 int Ndim[4],
                 int N3)
{
  FILE *fr;
  int i, j, k, s;
  int num;

  fr = fopen(file_name, "w");
  fprintf(fr, "CUBE file generated by qctoolkit package\n");
  fprintf(fr, "PLEASE CHECK THE RESUTLS\n");
  for(i=0;i<4;i++){
    s = 4*i;
    fprintf(fr, "%5d % 11.6f % 11.6f % 11.6f\n",
           Ndim[i], grid[s+1], grid[s+2], grid[s+3]);
  }
  for(i=0;i<Ndim[0];i++){
    s = 4*i;
    num = structure[s];
    fprintf(fr, "%5d % 11.6f % 11.6f % 11.6f % 11.6f\n",
           num, 
           structure[s], 
           structure[s+1], 
           structure[s+2], 
           structure[s+3]);
  }

  for(i=0;i<Ndim[1];i++){
    for(j=0;j<Ndim[2];j++){
      for(k=0;k<Ndim[3];k++){
        s = k + j*Ndim[3] + i*Ndim[2]*Ndim[3];
        fprintf(fr, " % 12.5E ", data[s]);
        if(k % 6 == 5) fprintf(fr, "\n");
      }
      fprintf(fr, "\n");
    }
  }

  fclose(fr);
}

void nplist_to_C_double_array(PyArrayObject *in_array, 
                              double *out_list,
                              int N)
{
  NpyIter *in_iter;
  NpyIter_IterNextFunc *in_iternext;
  double **in_ptr;
  int itr;

  in_iter = NpyIter_New(in_array, NPY_ITER_READONLY,
                        NPY_KEEPORDER, NPY_NO_CASTING, NULL);
  if (in_iter == NULL) goto fail;
  in_iternext = NpyIter_GetIterNext(in_iter, NULL);
  if (in_iternext == NULL){
    NpyIter_Deallocate(in_iter);
    goto fail;
  }
  /* interator pointer to actual numpy data */
  in_ptr = (double **) NpyIter_GetDataPtrArray(in_iter);
  itr=0;
  do {
    out_list[itr++] = **in_ptr;
  } while(in_iternext(in_iter));
  NpyIter_Deallocate(in_iter);

  fail:
    return NULL;
}

// !*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*! //
///////////////////////////////////////
// !!! PYTHON INTERFACE FROM HERE!!! //
///////////////////////////////////////
// !*!*!*!*!*!*!*!*!*!*!*!*!*!*!*!*! //

//////////////////////////////
// python callable function //
//////////////////////////////
// input: file_name, grid, structure, data 
// output: none
static PyObject * write_cube(PyObject * self, PyObject * args){
  char *file_name; // filename string as input
  PyObject *py_list_holder; // variable to pass python to C
  PyArrayObject *py_data; // numpy data from python
  PyArrayObject *py_structure; // numpy data from python
  PyArrayObject *py_grid; // numpy data from python
  double *data; // C-data need to be converted from python object
  double *structure; // C-data need to be converted from python object
  double *grid; // C-data need to be converted from python object
  int Ndim[4], N3, Ns;
  int i;

  // parse arguments check and/or error handling
  if(!PyArg_ParseTuple(args, "sO!O!O!", 
                       &file_name,
                       &PyArray_Type, &py_grid,
                       &PyArray_Type, &py_structure,
                       &PyArray_Type, &py_data
                      )) return NULL;
  if((py_grid == NULL)||(py_structure == NULL)||(py_data == NULL))
    return NULL;

  /*** access numpy array data ***/
  grid = (double *) malloc(16 * sizeof(double));
  nplist_to_C_double_array(py_grid, grid, 16);
  for(i=0;i<4;i++) Ndim[i] = abs(grid[i*4]);
  N3 = Ndim[1] * Ndim[2] * Ndim[3];
  Ns = Ndim[0] * 4;
  structure = (double *) malloc(Ns * sizeof(double));
  data = (double *) malloc(N3 * sizeof(double));

  nplist_to_C_double_array(py_structure, structure, Ns);
  nplist_to_C_double_array(py_data, data, N3);
  /*** end of list input data ***/

  writecube_c(file_name, grid, structure, data, Ndim, N3);
  free(grid);
  free(structure);
  free(data);

  return Py_BuildValue("");
}

/////////////////////////////////////////
// register python module symbol table //
/////////////////////////////////////////
// PyMethodDef: struct of four field
//   string: method_name
//   PyCFunction: method_function
//   int: flag
//   string: documentation
static PyMethodDef WriteCubeMethods[] = {
  {"write_cube", write_cube, METH_VARARGS, "write CUBE file"},
  {NULL, NULL, 0, NULL} // sentinel?
};

//////////////////////////
//  method constructor  //
//////////////////////////
// the name MUST be init{name} otherwise python cannot find it
// depends on numpy C-API, import_array()
// and/or import_ufunc() are necessary
// otherwise the code return segfault
PyMODINIT_FUNC initwrite_cube(void){
  Py_InitModule("write_cube", WriteCubeMethods);
  import_array(); // necessary!
}
